---
title: "Generate Real and Pseudo-absences"
author: "steppe"
date: "2023-12-06"
output: html_document
---

```{r load packages}
library(tidyverse)
library(sf)
source('functions.R')
```

```{r Create simplified BLM surface management, eval = F}
p1 <- '/media/steppe/hdd/geospatial/SMA_WM.gdb'

st_layers(p1)
ag <- st_read(p1, 'SurfaceMgtAgy_BLM') %>% 
  filter(ADMIN_ST != 'AK') %>% 
  rename(geometry = SHAPE) %>% 
  select(geometry) %>% 
  st_make_valid() %>% 
  st_union()

ag <- st_simplify(ag, dTolerance = 1000)
plot(ag)

pout <- '/media/steppe/hdd/SDM_restorations/data/raw/coarse_blm/'
st_write(ag, dsn = paste0(pout, 'coarse_surface.shp'))
```

We use absences while creating species distribution models. 
Both true absences, acquired from vegetation monitoring plots, and pseudo absences generated via geographic and environmental space are used. 

```{r load aim data for absences, eval = F}

p  <- '../data/raw/2021_AIM_Terrestrial/AIMTerrestrial9-1-22.gdb'
AIM_points <- st_read(dsn = p, layer = 'TerrADat', quiet = T) %>%
  select(PrimaryKey, DateVisited, geometry = Shape) %>% 
  st_transform(5070) 

pout <- '/media/steppe/hdd/SDM_restorations/data/raw/coarse_blm/'
blm_surf <- st_read(paste0(pout, 'coarse_surface.shp'), quiet = TRUE)
blm_surf <- st_simplify(blm_surf, dTolerance = 500) # just make it a bit smaller. 
blm_surf <- st_make_valid(blm_surf)
```

```{r generate raw absences, eval = F}

records <- st_read('../data/raw/occurrence/thinned/thinned_occurrences.shp', quiet = TRUE)
records <- records %>% 
  group_by(taxon) %>% 
  filter(n() >= 15)
records <- split(records, f = records$taxon)

out <- lapply(records, absence_drawer, bg_abs = 0.15)
out <- bind_rows(out)
st_write(out, '../data/raw/occurrence/absences.shp')

ab <- st_read('../data/raw/occurrence/absences.shp')
```



```{r remove pseudo absences in presence niche space}

library(klaR)
library(psych)
library(MASS)
library(ggord)

# to determine whether the pseudo-random absences are in areas which are possibly suitable
# we will use linear discrimination analysis (LDA). LDA uses a label, e.g. presence or absence
# as a response which can be predicted by independent variables which are linear combinations 
# generated by reducing a higher dimensional data set to two axis. LDA will be trained on a data set 
# of AIM Plots with true absences, geographic absences, and a subset of the Psuedo-absences. 
# Only up to 750:750 presences:absences per species will be used to train a model. The maximum
# imbalance between presences to absences will be 750:250, or 3:1. 

lda_PA_dropper <- function(x, path){
  
  pres <- x[x$Occurrence == 'Presence', ]
  real_abs <- x[x$PtType == 'AIM Absence', ]
  geo_abs <- x[x$PtType == 'Background Absence', ]
  model_abs <- dplyr::bind_rows(real_abs, geo_abs)

  if(nrow(pres) > 750){pres <- sample(1:nrow(pres), size = 750, replace = FALSE)}
  if(nrow(model_abs) > 750){model_abs <- sample(1:nrow(model_abs), size = 750, replace = FALSE)}

  training <- dplyr::bind_rows(pres, model_abs)
  testing <- filter(x, ! ID %in% training$ID)

  LDA_model <- lda(Species ~ ., training) # generate model

  # Here the accuracy of the trained modeled is evaluated
  LDA_train <- predict(LDA_model, training)$class
  tab <- table(Predicted = LDA_train, Actual = training$Species)
  ACC_train <- sum(diag(tab))/sum(tab) # accuracy

  # Here the model is applied to unclassified data
  LDA_test <- predict(LDA_model, testing)$class
  testing$Predicted <- predict(LDA_model, testing)$class
  tab1 <- table(Predicted = LDA_test, Actual = testing$Species)
  ACC_test <- sum(diag(tab1))/sum(tab1) # accuracy. 

  n_pres <- nrow(x[x$Occurrence == 'Presence',])
  n_abs <- nrow(x[x$Occurrence != 'Presence',])
  conflicted <- filter(testing, Predicted != Occurrence) 
  max_rcs_2_remove <- n_pres - n_ab

  if(nrow(conflicted) == 0){ # identify the records we want to remove from the test data. 
    removals <- NA
  } else if (nrow(conflicted) > max_rcs_2_remove) {
    removals <- conflicted[sample(1:nrow(conflicted), size = max_rcs_2_remove, replace = FALSE), 'ID']
  } else {
    removals <- conflicted$ID
  }
  
  if(!is.na(removals)){data_out <- dplyr::filter(x, ! ID %in% removals)}
  
  metrics <- data.frame(
    Presences = nrow(pres), 
    Absences = nrow(model_abs),
    ACC_train = ACC_train, 
    ACC_test = ACC_test,
    Flagged = nrow(conflicted)
    )
  
  species <- x$Taxon[1]
  message(length(removals), ' records dropped from ', species)
  species <- gsub(' ', '_', species)
  write.csv(metrics, file.path(path, paste0(species, '.csv')), row.names = FALSE)
  
  return(data_out)
}

```
