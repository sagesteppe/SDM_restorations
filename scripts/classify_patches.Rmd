---
title: "detect patches"
author: "steppe"
date: "2024-01-22"
output: html_document
---

```{r}
library(terra)
```



```{r}

p <- '../results/suitability_maps'
f <- file.path(p, list.files(p, pattern = '1k-'))
info <- lapply(f, file.info)

info1 <- info[[1]]$size/1e9

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu10R-line.tif') )
hydr_ftr <-  rast( file.path(gd, 'river_resistance', 'water_ftR.tif') )

patcheR <- function(x){
  
  # read in file
  r <- rast(x)
  taxon <- gsub('1k.*$', '', basename(x))
  pout <- '../results/patches'
  fsize <- file.info(f[1])$size/1e9
    
  # mask raster values < 0.8
  r <- terra::mask(r, ifel(r < 0.80, NA, r))
  
    # burn away rivers, and burn patches to hydrologic units ~ populations
  r <- terra::mask(r, terra::crop(hydr_bound, r), inverse = TRUE)
  r <- terra::mask(r, terra::crop(hydr_ftr, r), inverse = TRUE)
  
  # detect patches - this scales to the extent of analysis. #
  # Areas need to be aggregateed for computatations to be run in meaningful amount of
  # time
  
  if(fsize < 0.2){r1 <- r} else
    if(fsize < 0.4){r1 <- terra::aggregate(r, 2, fun = 'mean')} else 
      if(fsize < 0.7){r1 <- terra::aggregate(r, 3, fun = 'mean')} else
        {r1 <- terra::aggregate(r, 4, fun = 'mean')}

  pat <- terra::patches(r1,  directions = 4, allowGaps = FALSE)
  
  # remove patches < 5 acres
  sizes <- terra::zonal(cellSize(pat, unit="ha"), pat, sum, as.raster=TRUE)
  size_mask <- terra::ifel(sizes < 4.0470, NA, sizes)
  r1 <- mask(r1, size_mask)
  
  # resample the patches to the original raster resolution
  terra::resample(r1, r, threads = 16, method = 'near',
           filename = file.path(pout, paste0(taxon, '.tif')))
  
  terra::tmpFiles(current = FALSE, orphan = TRUE, old = TRUE, remove = TRUE)
  
}


lapply(f, patcheR)

```



```{r Patch metics to predict presence}

# euclidean nearest neighbor distance (enn) - (Patch)
## (modification) log(enn), sqrt(enn)
### Expectation: the number of colonized predicted patches decrease with increasing distance.
#### why: long-distance dispersal is limited from colonized to suitable patches. 
##### test: glm(colonization(0|1) ~ enn,  family = binomial)

# nearest neighbor distance (enn_mn) - (Class) # note other method of aggregation can be used too!
## (modification) log(enn_mn), sqrt(enn_mn)
### Expectation: the number of colonized predicted patches increases with increasing distance.
#### why: this species is adept at long distance dispersal
##### test: glm(colonization(0|1) ~ enn_mn,  family = binomial)


```


```{r Patch metrics to predict abundance}
# library(landscapemetrics)

# Patch level metrics. 
print(
  landscapemetrics::list_lsm(level = "class"))

# Core Area Index (cai)  
## (modification) arithmetic mean of core area cells
### Expectation: higher cai higher abundance
#### why: better within patch distribution, and a persistent 'source' to 'sink' peripheral cells. 
##### test: glmm?(% cover ~ cai, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# perimeter-area ratio (para)
## (modification) none
### Expectation: lower para higher abundance
#### why: areas with 'large edges' will suffer dispersal limitations throughout them, as many seeds will go to unsuitable habitat.
##### test: glmm?(% cover ~ para, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# fractal dimension index (frac)
## (modification) none
### Expectation: lower fractal dimensions (less complex patch shapes) have higher abundances. 
#### why: components of patches with complex shapes may suffer dispersal limitation. 
##### test: glmm?(% cover ~ frac, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

## to all models a term for the previous 4 years SPEI may be incorporated. 

```
