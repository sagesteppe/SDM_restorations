---
title: "detect patches"
author: "steppe"
date: "2024-01-22"
output: html_document
---

```{r}
library(terra)
library(tidyverse)
library(sf)
library(landscapemetrics)
source('functions.R')
```

Create coarse patches for 'meta-populations'

```{r, eval = F}

p <- '../results/suitability_maps'
f <- file.path(p, list.files(p, pattern = '1k-'))

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu10R-line.tif') )
hydr_ftr <-  rast( file.path(gd, 'river_resistance', 'water_ftR.tif') )
rm(gd)


lapply(f, patcheR) # roughly 72 hours. 

```



Create finer scale patches which more or less are meant to represent populations

```{r eval = F}

f <- list.files('../results/patches/')

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu12R-line.tif') )

landscapR <- function(x, pout, pRout){

  taxon <- gsub('[.]tif', '', basename(x))
  x <- terra::rast(file.path('../results/patches', x))
  x <- terra::ifel(x > 0, 1, NA)
  x <- terra::mask(x, terra::crop(hydr_bound, x), inverse = TRUE)
  landscape <- landscapemetrics::get_patches(x, directions = 4)
  calcs <- landscapemetrics::calculate_lsm(x, what = c('lsm_c_enn_mn', 'lsm_c_enn_cv',
                "lsm_p_enn", "lsm_p_cai", "lsm_p_para", "lsm_p_frac"), 
              neighbourhood = 4, directions = 4)

  p <- '../results/'
  write.csv(
    calcs[calcs$level == 'patch', c('id', 'metric', 'value')],
    file = paste0(p, pout, '/', taxon, '-', 'patch_vals.csv'),  row.names = F
  )

  write.csv(
    calcs[calcs$level == 'class', c('metric', 'value')],
    file = paste0(p, pout, '/', taxon, '-', 'class_vals.csv'), row.names = F
  )

  writeRaster(landscape[["layer_1"]][["class_1"]], 
    filename = paste0(p, pRout, '/', taxon, '-', 'patchIDS.tif')
  )

}

lapply(f, FUN = landscapR, pout = 'patch_metrics', pRout = 'fine_patches')

```


```{r Patch metics to predict presence}

# euclidean nearest neighbor distance (enn) - (Patch) {lsm_p_enn}
## (modification) log(enn), sqrt(enn)
### Expectation: the number of colonized predicted patches decrease with increasing distance.
#### why: long-distance dispersal is limited from colonized to suitable patches. 
##### test: glm(colonization(0|1) ~ enn,  family = binomial)

# nearest neighbor distance (enn_mn) - (Class) {lsm_c_enn_mn} # note other method of aggregation can be used too!
## (modification) log(enn_mn), sqrt(enn_mn)
### Expectation: the proportion of predicted patches which are colonized decreases with increaing mean distance between patches
#### why: further distances between suitable habitats prevent colonization and recolonization of habitat.
##### test: glm(prcnt_patches_colonized ~ enn_mn,  family = (quasi)binomial)


```


```{r Patch metrics to predict abundance}
# library(landscapemetrics)

# Patch level metrics. 
print(
  landscapemetrics::list_lsm(level = "class"))

# Core Area Index (cai)  {lsm_p_cai}
## (modification) arithmetic mean of core area cells
### Expectation: higher cai higher abundance
#### why: better within patch distribution, and a persistent 'source' to 'sink' peripheral cells. 
##### test: glmm?(% cover ~ cai, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# perimeter-area ratio (para) {lsm_p_para}
## (modification) none
### Expectation: lower para higher abundance
#### why: areas with 'large edges' will suffer dispersal limitations throughout them, as many seeds will go to unsuitable habitat.
##### test: glmm?(% cover ~ para, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# fractal dimension index (frac) {lsm_p_frac}
## (modification) none
### Expectation: lower fractal dimensions (less complex patch shapes) have higher abundances. 
#### why: components of patches with complex shapes may suffer dispersal limitation. 
##### test: glmm?(% cover ~ frac, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

## to all models a term for the previous 4 years SPEI may be incorporated. 

```

To determine whether a patch is occupied the original training data are matched as an attribute to the fine patches. 

```{r, eval = F}

f <- file.path('../results/fine_patches', list.files('../results/fine_patches'))
p <- '../data/raw/occurrence/combined_records'

recs <- lapply(
  file.path(p, list.files(p, pattern = '.shp$')), sf::st_read, quiet = TRUE) %>% 
  bind_rows() %>% 
  filter(Occurrence == 1)

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu12R-line.tif') )
hu12 <- rast('../../Geospatial_data/WBD_rast/hu12R.tif')

lapply(f, patchTaggR)
```

Combine all populated patches per species, something was amiss with identifying patches in marginal habitat, we will thin them down here. 

```{r}

f <- gsub('[.]tif$', '', list.files('../results/patches'))

combine_pop_patches <- function(x){

  pIDs <- read.csv(paste0('../results/occupiedPatches/', x, '-topSuitability.csv'))
  top_patches <- terra::rast(paste0('../results/fine_patches/', x, '-patchIDS.tif'))
  highest_no <- minmax(top_patches)[2]
  top_patches <- terra::subst(top_patches, pIDs$PatchID,  pIDs$PatchID, others = NA)
  names(top_patches)<- 'patches'
  pts <- st_read(paste0('../data/raw/occurrence/combined_records/', x, '.shp'), quiet = TRUE) |>
    dplyr::filter(Occurrence == 1)
  marg_patch <- terra::rast(paste0('../results/marginal_habitat/', x, '.tif'))

  fsize <- file.info(paste0('../results/marginal_habitat/', x, '.tif'))$size/1e9
  if(fsize < 0.025){marg_patch <- terra::patches(marg_patch, directions = 4)} else
    if(fsize > 0.025){marge1 <- terra::patches(terra::aggregate(marg_patch, 2, fun = 'mean'), directions = 4)} else
      if(fsize > 0.04){marge1 <- terra::patches(terra::aggregate(marg_patch, 3, fun = 'mean'), directions = 4)} else
        if(fsize > 0.05){marge1 <- terra::patches(terra::aggregate(marg_patch, 4, fun = 'mean'), directions = 4)} else
          if(fsize > 0.06){marge1 <- terra::patches(terra::aggregate(marg_patch, 5, fun = 'mean'), directions = 4)} else
            if(fsize > 0.07){marge1 <- terra::patches(terra::aggregate(marg_patch, 6, fun = 'mean'), directions = 4)}
  if(exists('marge1')){marg_patch <- terra::resample(marge1, marg_patch, threads = 16, method = 'near')} 
  
  occ_pts <- terra::extract(marg_patch, terra::vect(pts), bind = TRUE) |>
    sf::st_as_sf()
  occ_poly <- dplyr::filter(occ_pts, is.na(patches)) |>
    sf::st_buffer(250) # we cut out 90, but let's go a bit further for corner cases.
  occ_poly <- terra::extract(marg_patch, terra::vect(occ_poly), weights = TRUE) %>% 
    dplyr::group_by(ID) |> # now make sure we get the patch with the 'most' overlap with the polygon
    tidyr::drop_na(patches) |> # these values actually NA. 
    dplyr::slice_max(weight, with_ties = F)

  occ_patches <- c(
    dplyr::filter(occ_pts, ! is.na(patches)) |>
      dplyr::pull(patches), 
    occ_poly$patches
  )
  
  if(length(occ_patches) > 0){ 
  
    marg_patch <- terra::subst(marg_patch, occ_patches,  occ_patches, others = NA)
    old_ID <- unique(marg_patch)$patches # gather and relabel patches 
    lkp <- data.frame(
      old_ID = old_ID,
      new_ID = highest_no + 1:length(old_ID)
    )
    marg_patch <- terra::subst(marg_patch, lkp$old_ID, lkp$new_ID)
    final_patches <- terra::cover(top_patches, marg_patch)
  
    terra::writeRaster(final_patches, paste0('../results/allOccupiedPatches/', x, '.tif'))
  } else {
    terra::writeRaster(top_patches, paste0('../results/allOccupiedPatches/', x, '.tif'))
  }
}

# lentiformis  NTIF

lapply(f[c(288:335)], combine_pop_patches) # 2:46
```

```{r create a polygon dataset, eval = F}

  f <- paste0('../results/allOccupiedPatches/', 
            list.files('../results/allOccupiedPatches/'))

tif2shp <- function(x){
  
  taxon <- gsub('.tif$', '',  basename(x))
  pg <- terra::as.polygons(rast(x)) %>% 
    sf::st_as_sf() %>% 
    sf::st_make_valid()
  
  sf::st_write(pg, paste0('../results/allOccupiedPatchesVector/', taxon, '.shp'), quiet = TRUE)
  
}

lapply(f, tif2shp)

```





```{r}
PLANTS <- read.csv('../data/raw/2024sos_species.csv') |>
  select(genus:symbol) |>
  unite(sctfcnm, genus:infraspecies, na.rm = TRUE)

p1 <- '../data/raw/2021_AIM_Terrestrial/AIMTerrestrial9-1-22.gdb'
st_layers(dsn = p1)

AIM_points <- st_read(dsn = p1, 
        layer = 'TerrADat', quiet = T) %>%
  select(PrimaryKey, DateVisited, geometry = Shape) %>% 
  st_transform(5070) 

lpi <- spp_richness <- st_read(dsn = p1, 
        layer = 'tbl LINE POINT INTERCEPT', quiet = T) %>% 
  select(SpeciesList, PrimaryKey) %>% 
  right_join(AIM_points, by = 'PrimaryKey') %>% 
  st_as_sf()  %>% 
  
  # NOW CALCULATE THE PERCENT COVER OF EACH SPECIES FROM LPI #
  # ...
   
  mutate(DateVisited = as.Date(DateVisited), .before = geometry) %>% 
  arrange(SpeciesList) %>% 
  right_join(., select(targets, taxon, symbol) %>% 
               distinct(), by = c('SpeciesList' = 'symbol' ))

# add the species names from USDA PLANTS CODES

# ...

AIM_abundance_retrievR <- function(x, aim_tables){
  
  
}

```


