---
title: "detect patches"
author: "steppe"
date: "2024-01-22"
output: html_document
---

```{r}
library(terra)
library(tidyverse)
library(sf)
library(landscapemetrics)
source('functions.R')
```

Create coarse patches for 'meta-populations'

```{r, eval = F}

p <- '../results/suitability_maps'
f <- file.path(p, list.files(p, pattern = '1k-'))

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu10R-line.tif') )
hydr_ftr <-  rast( file.path(gd, 'river_resistance', 'water_ftR.tif') )
rm(gd)


lapply(f, patcheR) # roughly 72 hours. 

```



Create finer scale patches which more or less are meant to represent populations

```{r eval = F}

f <- list.files('../results/patches/')

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu12R-line.tif') )

lapply(f, FUN = landscapR, pout = 'patch_metrics', pRout = 'fine_patches')

```


```{r Patch metics to predict presence}

# euclidean nearest neighbor distance (enn) - (Patch) {lsm_p_enn}
## (modification) log(enn), sqrt(enn)
### Expectation: the number of colonized predicted patches decrease with increasing distance.
#### why: long-distance dispersal is limited from colonized to suitable patches. 
##### test: glm(colonization(0|1) ~ enn,  family = binomial)

# nearest neighbor distance (enn_mn) - (Class) {lsm_c_enn_mn} # note other method of aggregation can be used too!
## (modification) log(enn_mn), sqrt(enn_mn)
### Expectation: the proportion of predicted patches which are colonized decreases with increaing mean distance between patches
#### why: further distances between suitable habitats prevent colonization and recolonization of habitat.
##### test: glm(prcnt_patches_colonized ~ enn_mn,  family = (quasi)binomial)


```


```{r Patch metrics to predict abundance}
# library(landscapemetrics)

# Patch level metrics. 
print(
  landscapemetrics::list_lsm(level = "class"))

# Core Area Index (cai)  {lsm_p_cai}
## (modification) arithmetic mean of core area cells
### Expectation: higher cai higher abundance
#### why: better within patch distribution, and a persistent 'source' to 'sink' peripheral cells. 
##### test: glmm?(% cover ~ cai, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# perimeter-area ratio (para) {lsm_p_para}
## (modification) none
### Expectation: lower para higher abundance
#### why: areas with 'large edges' will suffer dispersal limitations throughout them, as many seeds will go to unsuitable habitat.
##### test: glmm?(% cover ~ para, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# fractal dimension index (frac) {lsm_p_frac}
## (modification) none
### Expectation: lower fractal dimensions (less complex patch shapes) have higher abundances. 
#### why: components of patches with complex shapes may suffer dispersal limitation. 
##### test: glmm?(% cover ~ frac, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

## to all models a term for the previous 4 years SPEI may be incorporated. 

```

To determine whether a patch is occupied the original training data are matched as an attribute to the fine patches. 

```{r, eval = F}

f <- file.path('../results/fine_patches', list.files('../results/fine_patches'))
p <- '../data/raw/occurrence/combined_records'

recs <- lapply(
  file.path(p, list.files(p, pattern = '.shp$')), sf::st_read, quiet = TRUE) %>% 
  bind_rows() %>% 
  filter(Occurrence == 1)

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu12R-line.tif') )
hu12 <- rast('../../Geospatial_data/WBD_rast/hu12R.tif')

lapply(f, patchTaggR)
```

Combine all populated patches per species, something was amiss with identifying patches in marginal habitat, we will thin them down here. 

```{r, eval = F}

f <- gsub('[.]tif$', '', list.files('../results/patches'))

# lentiformis  NTIF

lapply(f, combine_pop_patches) # 2:46
```

```{r create polygon datasets of patches, eval = F}

f <- paste0('../results/allOccupiedPatches/', 
        list.files('../results/allOccupiedPatches/'))

tif2shp <- function(x){
  
  taxon <- gsub('.tif$', '',  basename(x))
  pg <- terra::as.polygons(rast(x)) %>% 
    sf::st_as_sf() %>% 
    sf::st_make_valid()
  
  sf::st_write(pg, paste0('../results/allOccupiedPatchesVector/', taxon, '.shp'), quiet = TRUE)
  
}

lapply(f, tif2shp)

f <- paste0('../results/fine_patches/', 
        list.files('../results/fine_patches/'))

tif2shp <- function(x){
  
  taxon <- gsub('.tif$', '',  basename(x))
  pg <- terra::as.polygons(rast(x)) %>% 
    sf::st_as_sf() %>% 
    sf::st_make_valid()
  
  sf::st_write(pg, paste0('../results/fine_patchesVector/', taxon, '.shp'), quiet = TRUE)
  
}

lapply(f, tif2shp)

```


detect neighboring patches

```{r detect neighboring patches up to 5 orders}

f <- list.files('../results/allOccupiedPatchesVector', pattern = 'shp$')

#' identify contiguous neighbors and count them. 
#' @param x 
neigh_type <- function(x){
  
  # assemble the data sets. 
  taxon <- gsub('.shp$', '', basename(x))
  pm <- read.csv(paste0('../results/patch_metrics/', taxon, '-patch_vals.csv')) %>% 
    dplyr::filter(metric == 'cai' & value > 0) %>% 
    dplyr::select(id)

  occ <- sf::st_read(paste0('../results/allOccupiedPatchesVector/', taxon, '.shp'), quiet = T) |> 
    dplyr::mutate(Presence = 'Known')
  pred <- sf::st_read(paste0('../results/fine_patchesVector/', taxon, '-patchIDS.shp'), quiet = T) |> 
    dplyr::mutate(Presence = 'Predicted') |> 
    dplyr::filter(lyr_1 %in% pm$id) # filter for core area indexes

  pred1 <- pred[ lengths(sf::st_covers(pred, occ)) == 0, ] # make this dataset distinct. 
  pred2 <- sf::st_buffer(pred1, dist = 80) # for up north. 
  pred2 <- sf::st_difference(pred2)
  
  occ <- sf::st_buffer(occ, dist = 80) # for up north. 
  occ <- sf::st_difference(occ)

  patches <- dplyr::bind_rows(occ, pred2) %>% 
    sf::st_difference()
  
  # identify contiguous neighbors 
  nblags <- spdep::nblag(
    neighbours = spdep::poly2nb(patches, queen = TRUE), maxlag = 5)

  # rows 1: here are presences. 
  known_r <- nrow(patches[patches$Presence=='Known',])

  # count the contiguous neighbors
  nblags <- rapply(nblags, function(x){x <- length(as.numeric(x[x <= known_r & x != 0]))}, how = 'replace')
  nblags <- data.table::rbindlist(nblags) %>% 
    t() %>% 
    as.data.frame() %>% 
    setNames(., c('FirstOrder', 'SecondOrder', 'ThirdOrder', 'FourthOrder', 'FifthOrder')) 
  rownames(nblags) <- 1:nrow(nblags)

  # count the proximal neighbors
  nbdist <- spdep::dnearneigh(x = st_centroid(patches), d1 = 0, d2 = 5000) # neighbors within 5k
  nbdist <- lapply(nbdist, function(x){x <- length(as.numeric(x[x <= known_r & x != 0]))})

  nbdist <- setNames(
    data.frame(as.matrix(nbdist)), 'OccupiedNeighborsIn5k')
  nbdist$OccupiedNeighborsIn5k <- as.numeric(nbdist$OccupiedNeighborsIn5k)

  dat <- cbind(nbdist, nblags) %>% 
    tibble::rownames_to_column('ROW') %>% 
    tidyr::pivot_longer(FirstOrder:FifthOrder, names_to = 'OrderConnection', values_to = 'NoConnections') %>% 
    dplyr::filter(ROW %in% 1:known_r | OccupiedNeighborsIn5k > 0 | NoConnections > 0)
  
  ranks <- dplyr::mutate(dat, 
         Rank = dplyr::case_when(
           OrderConnection == 'FirstOrder' & NoConnections >= 2 ~ 2, 
           OrderConnection == 'FirstOrder' & NoConnections == 1 ~ 3, 
           OrderConnection == 'SecondOrder' & NoConnections >= 3 ~ 4, 
           OrderConnection == 'SecondOrder' & NoConnections <= 2 ~ 5, 
           OrderConnection == 'ThirdOrder' & NoConnections >= 4 ~ 6, 
           OrderConnection == 'ThirdOrder' & NoConnections <= 3 ~ 7, 
           OccupiedNeighborsIn5k >= 3 ~ 5, 
           OccupiedNeighborsIn5k <= 2 ~ 6, 
           .default = as.numeric(7)
         )) |>
    dplyr::slice_min(Rank, n = 1, by = 'ROW') |>
    dplyr::select(ROW, Rank) |>
    dplyr::mutate(Rank = dplyr::if_else(ROW %in% 1:known_r, 1, Rank))

  x1 <- patches |>
    tidyr::unite('PatchIDCombined', c('patches', 'lyr_1'), na.rm = T) |>
    tibble::rownames_to_column('ROW') |>
    dplyr::right_join( ranks, by = 'ROW') |>
    dplyr::select(-ROW, -Presence, PchIDComb = PatchIDCombined)
  
  write.csv(dat, paste0('../results/connections/', taxon, '.csv'), row.names = F)
  sf::st_write(x1, paste0('../results/rankedPatches/', taxon, '.shp'), quiet = T, append = F)
    
}

lapply(f, neigh_type)

```




```{r}
PLANTS <- read.csv('../data/raw/2024sos_species.csv') |>
  select(genus:symbol) |>
  unite(sctfcnm, genus:infraspecies, na.rm = TRUE)

p1 <- '../data/raw/2021_AIM_Terrestrial/AIMTerrestrial9-1-22.gdb'
st_layers(dsn = p1)

AIM_points <- st_read(dsn = p1, 
        layer = 'TerrADat', quiet = T) %>%
  select(PrimaryKey, DateVisited, geometry = Shape) %>% 
  st_transform(5070) 

lpi <- spp_richness <- st_read(dsn = p1, 
        layer = 'tbl LINE POINT INTERCEPT', quiet = T) %>% 
  select(SpeciesList, PrimaryKey) %>% 
  right_join(AIM_points, by = 'PrimaryKey') %>% 
  st_as_sf()  %>% 
  
  # NOW CALCULATE THE PERCENT COVER OF EACH SPECIES FROM LPI #
  # ...
   
  mutate(DateVisited = as.Date(DateVisited), .before = geometry) %>% 
  arrange(SpeciesList) %>% 
  right_join(., select(targets, taxon, symbol) %>% 
               distinct(), by = c('SpeciesList' = 'symbol' ))

# add the species names from USDA PLANTS CODES

# ...

AIM_abundance_retrievR <- function(x, aim_tables){
  
  
}

```


