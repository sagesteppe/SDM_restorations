---
title: "detect patches"
author: "steppe"
date: "2024-01-22"
output: html_document
---

```{r}
library(terra)
library(tidyverse)
library(sf)
library(landscapemetrics)
```

Create coarse patches for 'meta-populations'

```{r, eval = F}

p <- '../results/suitability_maps'
f <- file.path(p, list.files(p, pattern = '1k-'))

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu10R-line.tif') )
hydr_ftr <-  rast( file.path(gd, 'river_resistance', 'water_ftR.tif') )
rm(gd)


lapply(f, patcheR) # roughly 72 hours. 

```



Create finer scale patches which more or less are meant to represent populations

```{r eval = F}

f <- list.files('../results/patches/')

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu12R-line.tif') )

landscapR <- function(x, pout, pRout){

  taxon <- gsub('[.]tif', '', basename(x))
  x <- terra::rast(file.path('../results/patches', x))
  x <- terra::ifel(x > 0, 1, NA)
  x <- terra::mask(x, terra::crop(hydr_bound, x), inverse = TRUE)
  landscape <- landscapemetrics::get_patches(x, directions = 4)
  calcs <- landscapemetrics::calculate_lsm(x, what = c('lsm_c_enn_mn', 'lsm_c_enn_cv',
                "lsm_p_enn", "lsm_p_cai", "lsm_p_para", "lsm_p_frac"), 
              neighbourhood = 4, directions = 4)

  p <- '../results/'
  write.csv(
    calcs[calcs$level == 'patch', c('id', 'metric', 'value')],
    file = paste0(p, pout, '/', taxon, '-', 'patch_vals.csv'),  row.names = F
  )

  write.csv(
    calcs[calcs$level == 'class', c('metric', 'value')],
    file = paste0(p, pout, '/', taxon, '-', 'class_vals.csv'), row.names = F
  )

  writeRaster(landscape[["layer_1"]][["class_1"]], 
    filename = paste0(p, pRout, '/', taxon, '-', 'patchIDS.tif')
  )

}

lapply(f, FUN = landscapR, pout = 'patch_metrics', pRout = 'fine_patches')

```


```{r Patch metics to predict presence}

# euclidean nearest neighbor distance (enn) - (Patch) {lsm_p_enn}
## (modification) log(enn), sqrt(enn)
### Expectation: the number of colonized predicted patches decrease with increasing distance.
#### why: long-distance dispersal is limited from colonized to suitable patches. 
##### test: glm(colonization(0|1) ~ enn,  family = binomial)

# nearest neighbor distance (enn_mn) - (Class) {lsm_c_enn_mn} # note other method of aggregation can be used too!
## (modification) log(enn_mn), sqrt(enn_mn)
### Expectation: the proportion of predicted patches which are colonized decreases with increaing mean distance between patches
#### why: further distances between suitable habitats prevent colonization and recolonization of habitat.
##### test: glm(prcnt_patches_colonized ~ enn_mn,  family = (quasi)binomial)


```


```{r Patch metrics to predict abundance}
# library(landscapemetrics)

# Patch level metrics. 
print(
  landscapemetrics::list_lsm(level = "class"))

# Core Area Index (cai)  {lsm_p_cai}
## (modification) arithmetic mean of core area cells
### Expectation: higher cai higher abundance
#### why: better within patch distribution, and a persistent 'source' to 'sink' peripheral cells. 
##### test: glmm?(% cover ~ cai, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# perimeter-area ratio (para) {lsm_p_para}
## (modification) none
### Expectation: lower para higher abundance
#### why: areas with 'large edges' will suffer dispersal limitations throughout them, as many seeds will go to unsuitable habitat.
##### test: glmm?(% cover ~ para, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# fractal dimension index (frac) {lsm_p_frac}
## (modification) none
### Expectation: lower fractal dimensions (less complex patch shapes) have higher abundances. 
#### why: components of patches with complex shapes may suffer dispersal limitation. 
##### test: glmm?(% cover ~ frac, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

## to all models a term for the previous 4 years SPEI may be incorporated. 

```

To determine whether a patch is occupied the original training data are matched as an attribute to the fine patches. 

```{r}

f <- file.path('../results/fine_patches', list.files('../results/fine_patches'))
p <- '../data/raw/occurrence/combined_records'

recs <- lapply(
  file.path(p, list.files(p, pattern = '.shp$')), sf::st_read, quiet = TRUE) %>% 
  bind_rows() %>% 
  filter(Occurrence == 1)

r1 <- rast(f[1])

patchTaggR <- function(x){
  
  r <- terra::rast(x)
  r_taxon <- gsub('_', ' ', gsub('-patchIDS[.]tif', '', basename(x)))
  occs <- dplyr::filter(recs, taxon == r_taxon) |>
    dplyr::mutate(ID = dplyr::row_number()) |>
    terra::vect()
  
  occ_pts <- terra::extract(r, occs, bind = TRUE) |>
    sf::st_as_sf()

  # if pts were NA, buffer to 90m, many occupied areas were 'cut' away by the 
  # hydrologic mapping. 
  occ_poly <- dplyr::filter(occ_pts, is.na(lyr.1)) |>
    sf::st_buffer(250) # we cut out 90, but let's go a bit further for corner cases.
  
  occ_poly <- terra::extract(r, occ_poly, weights = TRUE) %>% 
    dplyr::group_by(ID) |> # now make sure we get the patch with the 'most' overlap with the polygon
    tidyr::drop_na(lyr.1) |> # these values actually NA. 
    dplyr::slice_max(weight, with_ties = F) |>
    dplyr::left_join(filter(occ_pts) |>
                       select(-lyr.1), by = join_by('ID')) |>
    dplyr::select(-weight)
    
  occ_pops <- dplyr::bind_rows( # a data frame of all raster patch ID's with populations known from within
    # the last few decades in them. 
    tidyr::drop_na(occ_pts, lyr.1), occ_poly) |>
    dplyr::rename(PatchID = lyr.1)
  
  # write out summary values of the patch matching
  data.frame(
    noPres = , 
    PresTopSuitability =, # the number of presences located in top suitability patches
    UniquePatchID = , # the number of uniquelly identified patches
    NoPatchesTopSuitability =  # the total number of most suitable patches from the RASTER
  )
  
  occ_pops <- dplyr::distinct(occ_pops, PatchID, .keep_all = TRUE) |> # this is multiple pts per patch - not necessary for us. 
    sf::st_drop_geometry() |>
    dplyr::select(date, PatchID) |>
    dplyr::arrange(PatchID) |>
    write.csv(row.names = F,
            file.path('../results/occupiedPatches-topSuitability', paste0(r_taxon, '.csv')))
  
  # for points which were not patched to a most suitable patch, put them into a hydrologic basin
  
}

patchTaggR(f[1])
```


```{r}
PLANTS <- read.csv('../data/raw/2024sos_species.csv') |>
  select(genus:symbol) |>
  unite(sctfcnm, genus:infraspecies, na.rm = TRUE)

p1 <- '../data/raw/2021_AIM_Terrestrial/AIMTerrestrial9-1-22.gdb'
st_layers(dsn = p1)

AIM_points <- st_read(dsn = p1, 
        layer = 'TerrADat', quiet = T) %>%
  select(PrimaryKey, DateVisited, geometry = Shape) %>% 
  st_transform(5070) 

lpi <- spp_richness <- st_read(dsn = p1, 
        layer = 'tbl LINE POINT INTERCEPT', quiet = T) %>% 
  select(SpeciesList, PrimaryKey) %>% 
  right_join(AIM_points, by = 'PrimaryKey') %>% 
  st_as_sf()  %>% 
  
  # NOW CALCULATE THE PERCENT COVER OF EACH SPECIES FROM LPI #
  # ...
   
  mutate(DateVisited = as.Date(DateVisited), .before = geometry) %>% 
  arrange(SpeciesList) %>% 
  right_join(., select(targets, taxon, symbol) %>% 
               distinct(), by = c('SpeciesList' = 'symbol' ))

# add the species names from USDA PLANTS CODES

# ...

AIM_abundance_retrievR <- function(x, aim_tables){
  
  
  
  
}

```


