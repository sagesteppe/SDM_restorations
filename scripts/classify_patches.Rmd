---
title: "detect patches"
author: "steppe"
date: "2024-01-22"
output: html_document
---

```{r}
library(terra)
```

```{r}
p <- '../results/suitability_maps'
r <- rast(file.path(p, 'Acamptopappus_sphaerocephalus1k-2024-01-10_08:57:46.tif'))
msk <- ifel(r < 0.80, NA, r)
m <- mask(r, msk)

m <- mask(m, crop(hydr_bound, m), inverse = TRUE)
plot(m)
m1 <- aggregate(m, 2, fun = 'mean')

# aggregate the raster to speed up the patch detection process. 
```

aggregation by a factor of 2 allows for quick patch delineation and detection. 


We need to identify and names patches. 

```{r}
system.time({ob <- terra::patches(m1,  directions = 4, allowgaps = FALSE)})
system.time({sizes =  zonal(cellSize(ob, unit="ha"), ob, sum, as.raster=TRUE) }) # use this has a mask
size_mask = ifel(sizes < 2.0235, NA, sizes) # remove areas < 5 acres.
ob <- mask(ob, z)
plot(ob)
```



```{r}

p <- '../results/suitability_maps'
f <- file.path(p, list.files(p, pattern = '1k-'))

gd <- '/media/steppe/hdd/Geospatial_data'
hydr_bound <- rast( file.path(gd, 'WBD_rast', 'hu10R-line.tif') )
hydr_ftr <-  rast( file.path(gd, 'river_resistance', 'water_ftR.tif') )


patcheR <- function(x){
  
  # read in file
  r <- rast(x)
  taxon <- gsub('1k.*$', '', basename(x))
  pout <- '../results/patches'
  
  # mask raster values < 0.8
  r <- terra::mask(r, ifel(r < 0.80, NA, r))
  
    # burn away rivers, and burn patches to hydrologic units ~ populations
  r <- terra::mask(r, terra::crop(hydr_bound, r), inverse = TRUE)
  r <- terra::mask(r, terra::crop(hydr_ftr, r), inverse = TRUE)
  
  # detect patches
  r1 <- terra::aggregate(r, 2, fun = 'mean')
  pat <- terra::patches(r1,  directions = 4, allowGaps = FALSE)
  
  # remove patches < 5 acres
  sizes <- terra::zonal(cellSize(pat, unit="ha"), pat, sum, as.raster=TRUE)
  size_mask <- terra::ifel(sizes < 4.0470, NA, sizes)
  r1 <- mask(r1, size_mask)
  
  # resample the patches to the original raster resolution
  terra::resample(r1, r, threads = 16, method = 'near',
           filename = file.path(pout, paste0(taxon, '.tif')))
  
}


lapply(f[4:335], patcheR)


```



```{r Patch metics to predict presence}

# euclidean nearest neighbor distance (enn) - (Patch)
## (modification) log(enn), sqrt(enn)
### Expectation: the number of colonized predicted patches decrease with increasing distance.
#### why: long-distance dispersal is limited from colonized to suitable patches. 
##### test: glm(colonization(0|1) ~ enn,  family = binomial)

# nearest neighbor distance (enn_mn) - (Class) # note other method of aggregation can be used too!
## (modification) log(enn_mn), sqrt(enn_mn)
### Expectation: the number of colonized predicted patches increases with increasing distance.
#### why: this species is adept at long distance dispersal
##### test: glm(colonization(0|1) ~ enn_mn,  family = binomial)


```


```{r Patch metrics to predict abundance}
# library(landscapemetrics)

# Patch level metrics. 
print(
  landscapemetrics::list_lsm(level = "class"))

# Core Area Index (cai)  
## (modification) arithmetic mean of core area cells
### Expectation: higher cai higher abundance
#### why: better within patch distribution, and a persistent 'source' to 'sink' peripheral cells. 
##### test: glmm?(% cover ~ cai, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# perimeter-area ratio (para)
## (modification) none
### Expectation: lower para higher abundance
#### why: areas with 'large edges' will suffer dispersal limitations throughout them, as many seeds will go to unsuitable habitat.
##### test: glmm?(% cover ~ para, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

# fractal dimension index (frac)
## (modification) none
### Expectation: lower fractal dimensions (less complex patch shapes) have higher abundances. 
#### why: components of patches with complex shapes may suffer dispersal limitation. 
##### test: glmm?(% cover ~ frac, correlation = nlme::corExp(Long ~ Lat, nugget=T), family = quasibinomial)

## to all models a term for the previous 4 years SPEI may be incorporated. 

```
